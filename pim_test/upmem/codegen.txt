// Function: main_kernel
#include <stdint.h>
#include <stdio.h>
#include <defs.h>
#include <mram.h>
#include <alloc.h>
#include <barrier.h>
#include <seqread.h>
#include <handshake.h>

typedef struct { int32_t x, y, z; } BlockInfo;
BARRIER_INIT(barrier, NR_TASKLETS);

__host BlockInfo blockIdx;

inline int min(int x, int y) { return x < y ? x : y; }
inline int max(int x, int y) { return x > y ? x : y; }
__mram_noinit int32_t A[24576];
__mram int32_t B[512];
__mram int32_t C_rf_global[48];
int main() {
  const int blockIdx_x = blockIdx.x;
  const int blockIdx_y = blockIdx.y;
  const int blockIdx_z = blockIdx.z;

  unsigned int tasklet_id = me();
  if (tasklet_id == 0) mem_reset();
  barrier_wait(&barrier);
  int32_t* C_rf_global_local = (int32_t*) mem_alloc(2 * sizeof(int32_t));
  int32_t* A_local = (int32_t*) mem_alloc(16 * sizeof(int32_t));
  int32_t* B_local = (int32_t*) mem_alloc(16 * sizeof(int32_t));
  for (int32_t i_3 = 0; i_3 < 2; ++i_3) {
    C_rf_global_local[i_3] = 0;
    for (int32_t k_1_0 = 0; k_1_0 < 32; ++k_1_0) {
      mram_read((__mram_ptr void*)(A + (((tasklet_id * 1024) + (i_3 * 512)) + (k_1_0 * 16))), A_local + 0, 64);
      mram_read((__mram_ptr void*)(B + (k_1_0 * 16)), B_local + 0, 64);
      for (int32_t k_1_1 = 0; k_1_1 < 16; ++k_1_1) {
        C_rf_global_local[i_3] = (C_rf_global_local[i_3] + (A_local[k_1_1] * B_local[k_1_1]));
      }
    }
  }
  mram_write(C_rf_global_local + 0, (__mram_ptr void*)(C_rf_global + (tasklet_id * 2)), 8);
}


// Function: main_kernel
#include <stdint.h>
#include <stdio.h>
#include <defs.h>
#include <mram.h>
#include <alloc.h>
#include <barrier.h>
#include <seqread.h>
#include <handshake.h>

typedef struct { int32_t x, y, z; } BlockInfo;
BARRIER_INIT(barrier, NR_TASKLETS);

__host BlockInfo blockIdx;

inline int min(int x, int y) { return x < y ? x : y; }
inline int max(int x, int y) { return x > y ? x : y; }
__mram_noinit int32_t A[8192];
__mram int32_t B[256];
__mram int32_t C_rf_global[32];
int main() {
  const int blockIdx_x = blockIdx.x;
  const int blockIdx_y = blockIdx.y;
  const int blockIdx_z = blockIdx.z;

  unsigned int tasklet_id = me();
  if (tasklet_id == 0) mem_reset();
  barrier_wait(&barrier);
  int32_t* C_rf_global_local = (int32_t*) mem_alloc(1 * sizeof(int32_t));
  int32_t* A_local = (int32_t*) mem_alloc(8 * sizeof(int32_t));
  int32_t* B_local = (int32_t*) mem_alloc(8 * sizeof(int32_t));
  for (int32_t i_2 = 0; i_2 < 2; ++i_2) {
    C_rf_global_local[0] = 0;
    for (int32_t k_1_0 = 0; k_1_0 < 32; ++k_1_0) {
      mram_read((__mram_ptr void*)(A + (((tasklet_id * 512) + (i_2 * 256)) + (k_1_0 * 8))), A_local + 0, 32);
      mram_read((__mram_ptr void*)(B + (k_1_0 * 8)), B_local + 0, 32);
      for (int32_t k_1_1 = 0; k_1_1 < 8; ++k_1_1) {
        C_rf_global_local[0] = (C_rf_global_local[0] + (A_local[k_1_1] * B_local[k_1_1]));
      }
    }
    C_rf_global[((tasklet_id * 2) + i_2)] = C_rf_global_local[0];
  }
}


// Function: main_kernel
#include <stdint.h>
#include <stdio.h>
#include <defs.h>
#include <mram.h>
#include <alloc.h>
#include <barrier.h>
#include <seqread.h>
#include <handshake.h>

typedef struct { int32_t x, y, z; } BlockInfo;
BARRIER_INIT(barrier, NR_TASKLETS);

__host BlockInfo blockIdx;

inline int min(int x, int y) { return x < y ? x : y; }
inline int max(int x, int y) { return x > y ? x : y; }
__mram_noinit int32_t A[32768];
__mram int32_t B[256];
__mram int32_t C_rf_global[128];
int main() {
  const int blockIdx_x = blockIdx.x;
  const int blockIdx_y = blockIdx.y;
  const int blockIdx_z = blockIdx.z;

  unsigned int tasklet_id = me();
  if (tasklet_id == 0) mem_reset();
  barrier_wait(&barrier);
  int32_t* C_rf_global_local = (int32_t*) mem_alloc(4 * sizeof(int32_t));
  int32_t* A_local = (int32_t*) mem_alloc(8 * sizeof(int32_t));
  int32_t* B_local = (int32_t*) mem_alloc(8 * sizeof(int32_t));
  for (int32_t i_2 = 0; i_2 < 2; ++i_2) {
    for (int32_t i_3 = 0; i_3 < 4; ++i_3) {
      C_rf_global_local[i_3] = 0;
      for (int32_t k_1_0 = 0; k_1_0 < 32; ++k_1_0) {
        mram_read((__mram_ptr void*)(A + ((((tasklet_id * 2048) + (i_2 * 1024)) + (i_3 * 256)) + (k_1_0 * 8))), A_local + 0, 32);
        mram_read((__mram_ptr void*)(B + (k_1_0 * 8)), B_local + 0, 32);
        for (int32_t k_1_1 = 0; k_1_1 < 8; ++k_1_1) {
          C_rf_global_local[i_3] = (C_rf_global_local[i_3] + (A_local[k_1_1] * B_local[k_1_1]));
        }
      }
    }
    mram_write(C_rf_global_local + 0, (__mram_ptr void*)(C_rf_global + ((tasklet_id * 8) + (i_2 * 4))), 16);
  }
}


// Function: main_kernel
#include <stdint.h>
#include <stdio.h>
#include <defs.h>
#include <mram.h>
#include <alloc.h>
#include <barrier.h>
#include <seqread.h>
#include <handshake.h>

typedef struct { int32_t x, y, z; } BlockInfo;
BARRIER_INIT(barrier, NR_TASKLETS);

__host BlockInfo blockIdx;

inline int min(int x, int y) { return x < y ? x : y; }
inline int max(int x, int y) { return x > y ? x : y; }
__mram_noinit int32_t A[32768];
__mram int32_t B[512];
__mram int32_t C_rf_global[64];
int main() {
  const int blockIdx_x = blockIdx.x;
  const int blockIdx_y = blockIdx.y;
  const int blockIdx_z = blockIdx.z;

  unsigned int tasklet_id = me();
  if (tasklet_id == 0) mem_reset();
  barrier_wait(&barrier);
  int32_t* C_rf_global_local = (int32_t*) mem_alloc(4 * sizeof(int32_t));
  int32_t* A_local = (int32_t*) mem_alloc(8 * sizeof(int32_t));
  int32_t* B_local = (int32_t*) mem_alloc(8 * sizeof(int32_t));
  for (int32_t i_3 = 0; i_3 < 4; ++i_3) {
    C_rf_global_local[i_3] = 0;
    for (int32_t k_1_0 = 0; k_1_0 < 64; ++k_1_0) {
      mram_read((__mram_ptr void*)(A + (((tasklet_id * 2048) + (i_3 * 512)) + (k_1_0 * 8))), A_local + 0, 32);
      mram_read((__mram_ptr void*)(B + (k_1_0 * 8)), B_local + 0, 32);
      for (int32_t k_1_1 = 0; k_1_1 < 8; ++k_1_1) {
        C_rf_global_local[i_3] = (C_rf_global_local[i_3] + (A_local[k_1_1] * B_local[k_1_1]));
      }
    }
  }
  mram_write(C_rf_global_local + 0, (__mram_ptr void*)(C_rf_global + (tasklet_id * 4)), 16);
}


// Function: main_kernel
#include <stdint.h>
#include <stdio.h>
#include <defs.h>
#include <mram.h>
#include <alloc.h>
#include <barrier.h>
#include <seqread.h>
#include <handshake.h>

typedef struct { int32_t x, y, z; } BlockInfo;
BARRIER_INIT(barrier, NR_TASKLETS);

__host BlockInfo blockIdx;

inline int min(int x, int y) { return x < y ? x : y; }
inline int max(int x, int y) { return x > y ? x : y; }
__mram_noinit int32_t A[38400];
__mram int32_t B[640];
__mram int32_t C_rf_global[60];
int main() {
  const int blockIdx_x = blockIdx.x;
  const int blockIdx_y = blockIdx.y;
  const int blockIdx_z = blockIdx.z;

  unsigned int tasklet_id = me();
  if (tasklet_id == 0) mem_reset();
  barrier_wait(&barrier);
  int32_t* C_rf_global_local = (int32_t*) mem_alloc(2 * sizeof(int32_t));
  int32_t* A_local = (int32_t*) mem_alloc(8 * sizeof(int32_t));
  int32_t* B_local = (int32_t*) mem_alloc(8 * sizeof(int32_t));
  for (int32_t i_2 = 0; i_2 < 2; ++i_2) {
    for (int32_t i_3 = 0; i_3 < 2; ++i_3) {
      C_rf_global_local[i_3] = 0;
      for (int32_t k_1_0 = 0; k_1_0 < 80; ++k_1_0) {
        mram_read((__mram_ptr void*)(A + ((((tasklet_id * 2560) + (i_2 * 1280)) + (i_3 * 640)) + (k_1_0 * 8))), A_local + 0, 32);
        mram_read((__mram_ptr void*)(B + (k_1_0 * 8)), B_local + 0, 32);
        for (int32_t k_1_1 = 0; k_1_1 < 8; ++k_1_1) {
          C_rf_global_local[i_3] = (C_rf_global_local[i_3] + (A_local[k_1_1] * B_local[k_1_1]));
        }
      }
    }
    mram_write(C_rf_global_local + 0, (__mram_ptr void*)(C_rf_global + ((tasklet_id * 4) + (i_2 * 2))), 8);
  }
}


// Function: main_kernel
#include <stdint.h>
#include <stdio.h>
#include <defs.h>
#include <mram.h>
#include <alloc.h>
#include <barrier.h>
#include <seqread.h>
#include <handshake.h>

typedef struct { int32_t x, y, z; } BlockInfo;
BARRIER_INIT(barrier, NR_TASKLETS);

__host BlockInfo blockIdx;

inline int min(int x, int y) { return x < y ? x : y; }
inline int max(int x, int y) { return x > y ? x : y; }
__mram_noinit int32_t A[12800];
__mram int32_t B[160];
__mram int32_t C_rf_global[80];
int main() {
  const int blockIdx_x = blockIdx.x;
  const int blockIdx_y = blockIdx.y;
  const int blockIdx_z = blockIdx.z;

  unsigned int tasklet_id = me();
  if (tasklet_id == 0) mem_reset();
  barrier_wait(&barrier);
  int32_t* C_rf_global_local = (int32_t*) mem_alloc(2 * sizeof(int32_t));
  int32_t* A_local = (int32_t*) mem_alloc(8 * sizeof(int32_t));
  int32_t* B_local = (int32_t*) mem_alloc(8 * sizeof(int32_t));
  for (int32_t i_2 = 0; i_2 < 4; ++i_2) {
    for (int32_t i_3 = 0; i_3 < 2; ++i_3) {
      C_rf_global_local[i_3] = 0;
      for (int32_t k_1_0 = 0; k_1_0 < 20; ++k_1_0) {
        mram_read((__mram_ptr void*)(A + ((((tasklet_id * 1280) + (i_2 * 320)) + (i_3 * 160)) + (k_1_0 * 8))), A_local + 0, 32);
        mram_read((__mram_ptr void*)(B + (k_1_0 * 8)), B_local + 0, 32);
        for (int32_t k_1_1 = 0; k_1_1 < 8; ++k_1_1) {
          C_rf_global_local[i_3] = (C_rf_global_local[i_3] + (A_local[k_1_1] * B_local[k_1_1]));
        }
      }
    }
    mram_write(C_rf_global_local + 0, (__mram_ptr void*)(C_rf_global + ((tasklet_id * 8) + (i_2 * 2))), 8);
  }
}


// Function: main_kernel
#include <stdint.h>
#include <stdio.h>
#include <defs.h>
#include <mram.h>
#include <alloc.h>
#include <barrier.h>
#include <seqread.h>
#include <handshake.h>

typedef struct { int32_t x, y, z; } BlockInfo;
BARRIER_INIT(barrier, NR_TASKLETS);

__host BlockInfo blockIdx;

inline int min(int x, int y) { return x < y ? x : y; }
inline int max(int x, int y) { return x > y ? x : y; }
__mram_noinit int32_t A[51200];
__mram int32_t B[80];
__mram int32_t C_rf_global[640];
int main() {
  const int blockIdx_x = blockIdx.x;
  const int blockIdx_y = blockIdx.y;
  const int blockIdx_z = blockIdx.z;

  unsigned int tasklet_id = me();
  if (tasklet_id == 0) mem_reset();
  barrier_wait(&barrier);
  int32_t* C_rf_global_local = (int32_t*) mem_alloc(10 * sizeof(int32_t));
  int32_t* A_local = (int32_t*) mem_alloc(20 * sizeof(int32_t));
  int32_t* B_local = (int32_t*) mem_alloc(20 * sizeof(int32_t));
  for (int32_t i_2 = 0; i_2 < 4; ++i_2) {
    for (int32_t i_3 = 0; i_3 < 10; ++i_3) {
      C_rf_global_local[i_3] = 0;
      for (int32_t k_1_0 = 0; k_1_0 < 4; ++k_1_0) {
        mram_read((__mram_ptr void*)(A + ((((tasklet_id * 3200) + (i_2 * 800)) + (i_3 * 80)) + (k_1_0 * 20))), A_local + 0, 80);
        mram_read((__mram_ptr void*)(B + (k_1_0 * 20)), B_local + 0, 80);
        for (int32_t k_1_1 = 0; k_1_1 < 20; ++k_1_1) {
          C_rf_global_local[i_3] = (C_rf_global_local[i_3] + (A_local[k_1_1] * B_local[k_1_1]));
        }
      }
    }
    mram_write(C_rf_global_local + 0, (__mram_ptr void*)(C_rf_global + ((tasklet_id * 40) + (i_2 * 10))), 40);
  }
}


// Function: main_kernel
#include <stdint.h>
#include <stdio.h>
#include <defs.h>
#include <mram.h>
#include <alloc.h>
#include <barrier.h>
#include <seqread.h>
#include <handshake.h>

typedef struct { int32_t x, y, z; } BlockInfo;
BARRIER_INIT(barrier, NR_TASKLETS);

__host BlockInfo blockIdx;

inline int min(int x, int y) { return x < y ? x : y; }
inline int max(int x, int y) { return x > y ? x : y; }
__mram_noinit int32_t A[51200];
__mram int32_t B[320];
__mram int32_t C_rf_global[160];
int main() {
  const int blockIdx_x = blockIdx.x;
  const int blockIdx_y = blockIdx.y;
  const int blockIdx_z = blockIdx.z;

  unsigned int tasklet_id = me();
  if (tasklet_id == 0) mem_reset();
  barrier_wait(&barrier);
  int32_t* C_rf_global_local = (int32_t*) mem_alloc(1 * sizeof(int32_t));
  int32_t* A_local = (int32_t*) mem_alloc(20 * sizeof(int32_t));
  int32_t* B_local = (int32_t*) mem_alloc(20 * sizeof(int32_t));
  for (int32_t i_2 = 0; i_2 < 10; ++i_2) {
    C_rf_global_local[0] = 0;
    for (int32_t k_1_0 = 0; k_1_0 < 16; ++k_1_0) {
      mram_read((__mram_ptr void*)(A + (((tasklet_id * 3200) + (i_2 * 320)) + (k_1_0 * 20))), A_local + 0, 80);
      mram_read((__mram_ptr void*)(B + (k_1_0 * 20)), B_local + 0, 80);
      for (int32_t k_1_1 = 0; k_1_1 < 20; ++k_1_1) {
        C_rf_global_local[0] = (C_rf_global_local[0] + (A_local[k_1_1] * B_local[k_1_1]));
      }
    }
    C_rf_global[((tasklet_id * 10) + i_2)] = C_rf_global_local[0];
  }
}


// Function: main_kernel
#include <stdint.h>
#include <stdio.h>
#include <defs.h>
#include <mram.h>
#include <alloc.h>
#include <barrier.h>
#include <seqread.h>
#include <handshake.h>

typedef struct { int32_t x, y, z; } BlockInfo;
BARRIER_INIT(barrier, NR_TASKLETS);

__host BlockInfo blockIdx;

inline int min(int x, int y) { return x < y ? x : y; }
inline int max(int x, int y) { return x > y ? x : y; }
__mram_noinit int32_t A[75264];
__mram int32_t B[112];
__mram int32_t C_rf_global[672];
int main() {
  const int blockIdx_x = blockIdx.x;
  const int blockIdx_y = blockIdx.y;
  const int blockIdx_z = blockIdx.z;

  unsigned int tasklet_id = me();
  if (tasklet_id == 0) mem_reset();
  barrier_wait(&barrier);
  int32_t* C_rf_global_local = (int32_t*) mem_alloc(28 * sizeof(int32_t));
  int32_t* A_local = (int32_t*) mem_alloc(16 * sizeof(int32_t));
  int32_t* B_local = (int32_t*) mem_alloc(16 * sizeof(int32_t));
  for (int32_t i_3 = 0; i_3 < 28; ++i_3) {
    C_rf_global_local[i_3] = 0;
    for (int32_t k_1_0 = 0; k_1_0 < 7; ++k_1_0) {
      mram_read((__mram_ptr void*)(A + (((tasklet_id * 3136) + (i_3 * 112)) + (k_1_0 * 16))), A_local + 0, 64);
      mram_read((__mram_ptr void*)(B + (k_1_0 * 16)), B_local + 0, 64);
      for (int32_t k_1_1 = 0; k_1_1 < 16; ++k_1_1) {
        C_rf_global_local[i_3] = (C_rf_global_local[i_3] + (A_local[k_1_1] * B_local[k_1_1]));
      }
    }
  }
  mram_write(C_rf_global_local + 0, (__mram_ptr void*)(C_rf_global + (tasklet_id * 28)), 112);
}


// Function: main_kernel
#include <stdint.h>
#include <stdio.h>
#include <defs.h>
#include <mram.h>
#include <alloc.h>
#include <barrier.h>
#include <seqread.h>
#include <handshake.h>

typedef struct { int32_t x, y, z; } BlockInfo;
BARRIER_INIT(barrier, NR_TASKLETS);

__host BlockInfo blockIdx;

inline int min(int x, int y) { return x < y ? x : y; }
inline int max(int x, int y) { return x > y ? x : y; }
__mram_noinit int32_t A[28672];
__mram int32_t B[224];
__mram int32_t C_rf_global[128];
int main() {
  const int blockIdx_x = blockIdx.x;
  const int blockIdx_y = blockIdx.y;
  const int blockIdx_z = blockIdx.z;

  unsigned int tasklet_id = me();
  if (tasklet_id == 0) mem_reset();
  barrier_wait(&barrier);
  int32_t* C_rf_global_local = (int32_t*) mem_alloc(8 * sizeof(int32_t));
  int32_t* A_local = (int32_t*) mem_alloc(14 * sizeof(int32_t));
  int32_t* B_local = (int32_t*) mem_alloc(14 * sizeof(int32_t));
  for (int32_t i_3 = 0; i_3 < 8; ++i_3) {
    C_rf_global_local[i_3] = 0;
    for (int32_t k_1_0 = 0; k_1_0 < 16; ++k_1_0) {
      mram_read((__mram_ptr void*)(A + (((tasklet_id * 1792) + (i_3 * 224)) + (k_1_0 * 14))), A_local + 0, 56);
      mram_read((__mram_ptr void*)(B + (k_1_0 * 14)), B_local + 0, 56);
      for (int32_t k_1_1 = 0; k_1_1 < 14; ++k_1_1) {
        C_rf_global_local[i_3] = (C_rf_global_local[i_3] + (A_local[k_1_1] * B_local[k_1_1]));
      }
    }
  }
  mram_write(C_rf_global_local + 0, (__mram_ptr void*)(C_rf_global + (tasklet_id * 8)), 32);
}


// Function: main_kernel
#include <stdint.h>
#include <stdio.h>
#include <defs.h>
#include <mram.h>
#include <alloc.h>
#include <barrier.h>
#include <seqread.h>
#include <handshake.h>

typedef struct { int32_t x, y, z; } BlockInfo;
BARRIER_INIT(barrier, NR_TASKLETS);

__host BlockInfo blockIdx;

inline int min(int x, int y) { return x < y ? x : y; }
inline int max(int x, int y) { return x > y ? x : y; }
__mram_noinit int32_t A[100352];
__mram int32_t B[112];
__mram int32_t C_rf_global[896];
int main() {
  const int blockIdx_x = blockIdx.x;
  const int blockIdx_y = blockIdx.y;
  const int blockIdx_z = blockIdx.z;

  unsigned int tasklet_id = me();
  if (tasklet_id == 0) mem_reset();
  barrier_wait(&barrier);
  int32_t* C_rf_global_local = (int32_t*) mem_alloc(56 * sizeof(int32_t));
  int32_t* A_local = (int32_t*) mem_alloc(16 * sizeof(int32_t));
  int32_t* B_local = (int32_t*) mem_alloc(16 * sizeof(int32_t));
  for (int32_t i_3 = 0; i_3 < 56; ++i_3) {
    C_rf_global_local[i_3] = 0;
    for (int32_t k_1_0 = 0; k_1_0 < 7; ++k_1_0) {
      mram_read((__mram_ptr void*)(A + (((tasklet_id * 6272) + (i_3 * 112)) + (k_1_0 * 16))), A_local + 0, 64);
      mram_read((__mram_ptr void*)(B + (k_1_0 * 16)), B_local + 0, 64);
      for (int32_t k_1_1 = 0; k_1_1 < 16; ++k_1_1) {
        C_rf_global_local[i_3] = (C_rf_global_local[i_3] + (A_local[k_1_1] * B_local[k_1_1]));
      }
    }
  }
  mram_write(C_rf_global_local + 0, (__mram_ptr void*)(C_rf_global + (tasklet_id * 56)), 224);
}


// Function: main_kernel
#include <stdint.h>
#include <stdio.h>
#include <defs.h>
#include <mram.h>
#include <alloc.h>
#include <barrier.h>
#include <seqread.h>
#include <handshake.h>

typedef struct { int32_t x, y, z; } BlockInfo;
BARRIER_INIT(barrier, NR_TASKLETS);

__host BlockInfo blockIdx;

inline int min(int x, int y) { return x < y ? x : y; }
inline int max(int x, int y) { return x > y ? x : y; }
__mram_noinit int32_t A[100352];
__mram int32_t B[1792];
__mram int32_t C_rf_global[56];
int main() {
  const int blockIdx_x = blockIdx.x;
  const int blockIdx_y = blockIdx.y;
  const int blockIdx_z = blockIdx.z;

  unsigned int tasklet_id = me();
  if (tasklet_id == 0) mem_reset();
  barrier_wait(&barrier);
  int32_t* C_rf_global_local = (int32_t*) mem_alloc(2 * sizeof(int32_t));
  int32_t* A_local = (int32_t*) mem_alloc(14 * sizeof(int32_t));
  int32_t* B_local = (int32_t*) mem_alloc(14 * sizeof(int32_t));
  for (int32_t i_2 = 0; i_2 < 2; ++i_2) {
    for (int32_t i_3 = 0; i_3 < 2; ++i_3) {
      C_rf_global_local[i_3] = 0;
      for (int32_t k_1_0 = 0; k_1_0 < 128; ++k_1_0) {
        mram_read((__mram_ptr void*)(A + ((((tasklet_id * 7168) + (i_2 * 3584)) + (i_3 * 1792)) + (k_1_0 * 14))), A_local + 0, 56);
        mram_read((__mram_ptr void*)(B + (k_1_0 * 14)), B_local + 0, 56);
        for (int32_t k_1_1 = 0; k_1_1 < 14; ++k_1_1) {
          C_rf_global_local[i_3] = (C_rf_global_local[i_3] + (A_local[k_1_1] * B_local[k_1_1]));
        }
      }
    }
    mram_write(C_rf_global_local + 0, (__mram_ptr void*)(C_rf_global + ((tasklet_id * 4) + (i_2 * 2))), 8);
  }
}


// Function: main_kernel
#include <stdint.h>
#include <stdio.h>
#include <defs.h>
#include <mram.h>
#include <alloc.h>
#include <barrier.h>
#include <seqread.h>
#include <handshake.h>

typedef struct { int32_t x, y, z; } BlockInfo;
BARRIER_INIT(barrier, NR_TASKLETS);

__host BlockInfo blockIdx;

inline int min(int x, int y) { return x < y ? x : y; }
inline int max(int x, int y) { return x > y ? x : y; }
__mram_noinit int32_t A[73728];
__mram int32_t B[768];
__mram int32_t C_rf_global[96];
int main() {
  const int blockIdx_x = blockIdx.x;
  const int blockIdx_y = blockIdx.y;
  const int blockIdx_z = blockIdx.z;

  unsigned int tasklet_id = me();
  if (tasklet_id == 0) mem_reset();
  barrier_wait(&barrier);
  int32_t* C_rf_global_local = (int32_t*) mem_alloc(3 * sizeof(int32_t));
  int32_t* A_local = (int32_t*) mem_alloc(24 * sizeof(int32_t));
  int32_t* B_local = (int32_t*) mem_alloc(24 * sizeof(int32_t));
  for (int32_t i_2 = 0; i_2 < 2; ++i_2) {
    for (int32_t i_3 = 0; i_3 < 3; ++i_3) {
      C_rf_global_local[i_3] = 0;
      for (int32_t k_1_0 = 0; k_1_0 < 32; ++k_1_0) {
        mram_read((__mram_ptr void*)(A + ((((tasklet_id * 4608) + (i_2 * 2304)) + (i_3 * 768)) + (k_1_0 * 24))), A_local + 0, 96);
        mram_read((__mram_ptr void*)(B + (k_1_0 * 24)), B_local + 0, 96);
        for (int32_t k_1_1 = 0; k_1_1 < 24; ++k_1_1) {
          C_rf_global_local[i_3] = (C_rf_global_local[i_3] + (A_local[k_1_1] * B_local[k_1_1]));
        }
      }
    }
    for (int32_t ax1 = 0; ax1 < 3; ++ax1) {
      C_rf_global[(((tasklet_id * 6) + (i_2 * 3)) + ax1)] = C_rf_global_local[ax1];
    }
  }
}


// Function: main_kernel
#include <stdint.h>
#include <stdio.h>
#include <defs.h>
#include <mram.h>
#include <alloc.h>
#include <barrier.h>
#include <seqread.h>
#include <handshake.h>

typedef struct { int32_t x, y, z; } BlockInfo;
BARRIER_INIT(barrier, NR_TASKLETS);

__host BlockInfo blockIdx;

inline int min(int x, int y) { return x < y ? x : y; }
inline int max(int x, int y) { return x > y ? x : y; }
__mram_noinit int32_t A[294912];
__mram int32_t B[384];
__mram int32_t C_rf_global[768];
int main() {
  const int blockIdx_x = blockIdx.x;
  const int blockIdx_y = blockIdx.y;
  const int blockIdx_z = blockIdx.z;

  unsigned int tasklet_id = me();
  if (tasklet_id == 0) mem_reset();
  barrier_wait(&barrier);
  int32_t* C_rf_global_local = (int32_t*) mem_alloc(8 * sizeof(int32_t));
  int32_t* A_local = (int32_t*) mem_alloc(24 * sizeof(int32_t));
  int32_t* B_local = (int32_t*) mem_alloc(24 * sizeof(int32_t));
  for (int32_t i_2 = 0; i_2 < 6; ++i_2) {
    for (int32_t i_3 = 0; i_3 < 8; ++i_3) {
      C_rf_global_local[i_3] = 0;
      for (int32_t k_1_0 = 0; k_1_0 < 16; ++k_1_0) {
        mram_read((__mram_ptr void*)(A + ((((tasklet_id * 18432) + (i_2 * 3072)) + (i_3 * 384)) + (k_1_0 * 24))), A_local + 0, 96);
        mram_read((__mram_ptr void*)(B + (k_1_0 * 24)), B_local + 0, 96);
        for (int32_t k_1_1 = 0; k_1_1 < 24; ++k_1_1) {
          C_rf_global_local[i_3] = (C_rf_global_local[i_3] + (A_local[k_1_1] * B_local[k_1_1]));
        }
      }
    }
    mram_write(C_rf_global_local + 0, (__mram_ptr void*)(C_rf_global + ((tasklet_id * 48) + (i_2 * 8))), 32);
  }
}


// Function: main_kernel
#include <stdint.h>
#include <stdio.h>
#include <defs.h>
#include <mram.h>
#include <alloc.h>
#include <barrier.h>
#include <seqread.h>
#include <handshake.h>

typedef struct { int32_t x, y, z; } BlockInfo;
BARRIER_INIT(barrier, NR_TASKLETS);

__host BlockInfo blockIdx;

inline int min(int x, int y) { return x < y ? x : y; }
inline int max(int x, int y) { return x > y ? x : y; }
__mram_noinit int32_t A[294912];
__mram int32_t B[768];
__mram int32_t C_rf_global[384];
int main() {
  const int blockIdx_x = blockIdx.x;
  const int blockIdx_y = blockIdx.y;
  const int blockIdx_z = blockIdx.z;

  unsigned int tasklet_id = me();
  if (tasklet_id == 0) mem_reset();
  barrier_wait(&barrier);
  int32_t* C_rf_global_local = (int32_t*) mem_alloc(16 * sizeof(int32_t));
  int32_t* A_local = (int32_t*) mem_alloc(24 * sizeof(int32_t));
  int32_t* B_local = (int32_t*) mem_alloc(24 * sizeof(int32_t));
  for (int32_t i_3 = 0; i_3 < 16; ++i_3) {
    C_rf_global_local[i_3] = 0;
    for (int32_t k_1_0 = 0; k_1_0 < 32; ++k_1_0) {
      mram_read((__mram_ptr void*)(A + (((tasklet_id * 12288) + (i_3 * 768)) + (k_1_0 * 24))), A_local + 0, 96);
      mram_read((__mram_ptr void*)(B + (k_1_0 * 24)), B_local + 0, 96);
      for (int32_t k_1_1 = 0; k_1_1 < 24; ++k_1_1) {
        C_rf_global_local[i_3] = (C_rf_global_local[i_3] + (A_local[k_1_1] * B_local[k_1_1]));
      }
    }
  }
  mram_write(C_rf_global_local + 0, (__mram_ptr void*)(C_rf_global + (tasklet_id * 16)), 64);
}


