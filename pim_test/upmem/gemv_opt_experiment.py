import os, sys
sys.path.append("/root/dev/tvm/python")
os.chdir("/root/dev/tvm/pim_test/upmem")

from base import cleanup
from gemv import GEMV, gemvRCTile
import tvm

WHITE = "97"    # 흰색
RED = "91"      # 빨간색
PURPLE = "95"   # 보라색
GREEN = "92"    # 초록색
YELLOW = "93"   # 노란색
CYAN = "96"     # 청록색
BLUE = "34"     # 파란색

def colorize(text, color_code):
    """텍스트를 주어진 ANSI 색상 코드로 색칠"""
    return f"\033[{color_code}m{text}\033[0m"

mks = [(10000, 10000), (8209, 8209), (8175, 8209), (8209, 8175), (8175, 8175),
       (8209, 1035), (8209, 1013), (8175, 1035), (8175, 1013),
       (1035, 8209), (1013, 8209), (1035, 8175), (1013, 8175),
       ]
mks = [(999, 999), (1049, 999), (999, 1049), (1049, 1049),
           (1049, 261), (1049, 249), (999, 261), (999, 249),
            (261, 1049), (249, 1049), (261, 999), (249, 999),
            ]
configs = []

for M, K in mks:
    for bm, bk in [(8, 256), (16, 128), (32, 64), (64, 32)]:
        for c in [4, 16, 64]:
            dtype = "int32" if M % 2 == 0 and K % 2 == 0 else "int64"
            configs.append((M, K, bm, bk, 64, 16, c, dtype))

# configs = [
#     (10000, 10000, 16, 64, 16, 64, "int32"),
#     (10000, 10000, 4, 512, 16, 64, "int32"),
#     (10000, 10000, 8, 256, 16, 64, "int32"),
#     (10000, 10000, 16, 128, 16, 64, "int32"),
#     (10000, 10000, 32, 64, 16, 64, "int32"),
#     (10000, 10000, 64, 32, 16, 64, "int32"),


#     (999, 999, 16, 16, 64, 16, 64, "int64"),
#     (999, 999, 16, 16, 64, 16, 16, "int64"),
#     (999, 999, 16, 16, 64, 16, 8, "int64"),
#     (999, 999, 16, 16, 64, 16, 4, "int64"),
#     (999, 999, 16, 32, 64, 16, 64, "int64"),
#     (999, 999, 16, 32, 64, 16, 16, "int64"),
#     (999, 999, 16, 32, 64, 16, 8, "int64"),
#     (999, 999, 16, 32, 64, 16, 4, "int64"),
#     (999, 999, 16, 64, 64, 16, 64, "int64"),
#     (999, 999, 16, 64, 64, 16, 16, "int64"),
#     (999, 999, 16, 64, 64, 16, 8, "int64"),
#     (999, 999, 16, 64, 64, 16, 4, "int64"),
#     (999, 999, 32, 64, 64, 16, 64, "int64"),
#     (999, 999, 32, 64, 64, 16, 16, "int64"),
#     (999, 999, 32, 64, 64, 16, 8, "int64"),
#     (999, 999, 32, 64, 64, 16, 4, "int64"),

#     (1049, 1049, 16, 16, 64, 16, 64, "int64"),
#     (1049, 1049, 16, 16, 64, 16, 16, "int64"),
#     (1049, 1049, 16, 16, 64, 16, 8, "int64"),
#     (1049, 1049, 16, 16, 64, 16, 4, "int64"),
#     (1049, 1049, 16, 32, 64, 16, 64, "int64"),
#     (1049, 1049, 16, 32, 64, 16, 16, "int64"),
#     (1049, 1049, 16, 32, 64, 16, 8, "int64"),
#     (1049, 1049, 16, 32, 64, 16, 4, "int64"),
#     (1049, 1049, 16, 64, 64, 16, 64, "int64"),
#     (1049, 1049, 16, 64, 64, 16, 16, "int64"),
#     (1049, 1049, 16, 64, 64, 16, 8, "int64"),
#     (1049, 1049, 16, 64, 64, 16, 4, "int64"),
#     (1049, 1049, 32, 64, 64, 16, 64, "int64"),
#     (1049, 1049, 32, 64, 64, 16, 16, "int64"),
#     (1049, 1049, 32, 64, 64, 16, 8, "int64"),
#     (1049, 1049, 32, 64, 64, 16, 4, "int64"),

#     (999, 1049, 16, 16, 64, 16, 64, "int64"),
#     (999, 1049, 16, 16, 64, 16, 16, "int64"),
#     (999, 1049, 16, 16, 64, 16, 8, "int64"),
#     (999, 1049, 16, 16, 64, 16, 4, "int64"),
#     (999, 1049, 16, 32, 64, 16, 64, "int64"),
#     (999, 1049, 16, 32, 64, 16, 16, "int64"),
#     (999, 1049, 16, 32, 64, 16, 8, "int64"),
#     (999, 1049, 16, 32, 64, 16, 4, "int64"),
#     (999, 1049, 16, 64, 64, 16, 64, "int64"),
#     (999, 1049, 16, 64, 64, 16, 16, "int64"),
#     (999, 1049, 16, 64, 64, 16, 8, "int64"),
#     (999, 1049, 16, 64, 64, 16, 4, "int64"),
#     (999, 1049, 32, 64, 64, 16, 64, "int64"),
#     (999, 1049, 32, 64, 64, 16, 16, "int64"),
#     (999, 1049, 32, 64, 64, 16, 8, "int64"),
#     (999, 1049, 32, 64, 64, 16, 4, "int64"),

#     (1049, 999, 16, 16, 64, 16, 64, "int64"),
#     (1049, 999, 16, 16, 64, 16, 16, "int64"),
#     (1049, 999, 16, 16, 64, 16, 8, "int64"),
#     (1049, 999, 16, 16, 64, 16, 4, "int64"),
#     (1049, 999, 16, 32, 64, 16, 64, "int64"),
#     (1049, 999, 16, 32, 64, 16, 16, "int64"),
#     (1049, 999, 16, 32, 64, 16, 8, "int64"),
#     (1049, 999, 16, 32, 64, 16, 4, "int64"),
#     (1049, 999, 16, 64, 64, 16, 64, "int64"),
#     (1049, 999, 16, 64, 64, 16, 16, "int64"),
#     (1049, 999, 16, 64, 64, 16, 8, "int64"),
#     (1049, 999, 16, 64, 64, 16, 4, "int64"),
#     (1049, 999, 32, 64, 64, 16, 64, "int64"),
#     (1049, 999, 32, 64, 64, 16, 16, "int64"),
#     (1049, 999, 32, 64, 64, 16, 8, "int64"),
#     (1049, 999, 32, 64, 64, 16, 4, "int64"),

#     (2500, 2500, 32, 64, 64, 16, 64, "int32"),
#     (2500, 2500, 32, 64, 64, 16, 16, "int32"),
#     (2500, 2500, 32, 64, 64, 16, 8, "int32"),
#     (2500, 2500, 32, 64, 64, 16, 4, "int32"),
#     (2500, 2500, 64, 32, 64, 16, 64, "int32"),
#     (2500, 2500, 64, 32, 64, 16, 16, "int32"),
#     (2500, 2500, 64, 32, 64, 16, 8, "int32"),
#     (2500, 2500, 64, 32, 64, 16, 4, "int32"),
# ]

gemv = GEMV(warmup=1, repeat=10)
print("\t".join(["IDX", "OPT0", "OPT_A1", "OPT_A2", "OPT_A3", "OPT_A4", "OPT_A5", "M", "K", "n_xb", "n_yb", "n_rt", "n_yt", "cache", "dtype", "speedup1", "speedup4"]))
for k, (M, K, n_xb, n_yb, n_rt, n_yt, cache, dtype) in enumerate(configs):
    rets = []
    sources = []
    for opt_level in range(6):
        gemv.profile = f"opt{opt_level}"
        gemv.index = k
        with tvm.transform.PassContext(config={"tir.UpmemKernelOptimize": opt_level}):
            res = gemv.test(gemvRCTile, M=M, K=K, n_xb=n_xb, n_yb=n_yb, n_yt=n_yt, n_rt=n_rt, n_cache=cache, dtype=dtype)
            if res != "ERROR":
                sources.append(gemv.func.imported_modules[0].get_source())
            else:
                sources.append("ERROR")
            rets.append(res)

    times = []
    for i in range(6):
        try:
            times.append(float(rets[i]))
        except ValueError:
            times.append(-1)
    times_str = times.copy()

    shortest = times[1]
    base1 = times[1]
    base2 = times[4]

    for cfg in [[0, 1], [0, 1, 2], [0, 1, 2, 3], [0, 1, 2, 3, 4], [0, 1, 2, 3, 4, 5]]:
        cur = times[cfg[-1]]
        cmp = cfg[:-1]
        color = YELLOW
        for c in cmp:
            if sources[cfg[-1]] == sources[c]:
                cur = f"${c}"
                color = BLUE
        if color != BLUE:
            if abs(times[cfg[0]] - cur) < 0.01:
                color = WHITE     # 흰색
            elif times[cfg[0]] < cur:
                color = RED       # 빨간색
            elif all([t >= cur for t in times]):
                color = CYAN   # cyan
                shortest = cur
            elif all([times[c] > cur for c in cmp]):
                color = GREEN     # 초록색
        times_str[cfg[-1]] = colorize(cur, color)
        speedup1 = f"{((base1 / shortest - 1) * 100):.2f}%"
        speedup4 = f"{((base2 / shortest - 1) * 100):.2f}%"
    print("\t".join([str(x) for x in [k, *times_str, M, K, n_xb, n_yb, n_rt, n_yt, cache, dtype, speedup1, speedup4]]))